/**
 * 제네릭(Generic) - 일반적인, 포괄적인
 * 제네릭 함수로 만들어주면 함수의 인수에 따라서
 * 반환값을 가변적으로 정해줄 수 있다.
 * -> 제네럴(종합적인)
 * ex. general hospital (종합병원)과 유사하다.
 * 즉, 제네릭 함수는 모든 타입에 두루두루 쓸 수 있는 범용적인 함수
 */

{
  // 내가 넘겨주는 값에 따라 타입이 정해주길 원한다면..
  // any 타입
  // 함수는 리턴값을 기준으로 타입을 추론하지만 매개변수의 타입이  any 이다보니
  // 반환값도 any 타입으로 추론되는 문제점이 있다
  // 즉, 어떻게 호출하고 어떤 인수를 전달하더라도 어차피 any 타입을 반환한다고 되어 있기 때문에
  // any 타입으로 추론되고 있다.
  function func(value: any) {
    return value;
  }

  let num = func(10);
  num.toUpperCase(); // 오류가 발새해야함에도 불구하고 any 타입이라서 오류 발생이 안되는 문제가 있음

  let bool = func(true);

  let str = func("김재희");
}

//

{
  // unknown 을 타입으로 지정한 경우...
  function func(value: unknown) {
    return value;
  }

  let num = func(10);
  num.toUpperCase(); // 오류가 발생하지만...
  num.toFixed(); // number 값인데도 toFixed 에서 오류가 발생하는 문제가 있음

  // 타입 좁히기를 사용해야함.
  // unknown 타입을 정의해도 타입 좁히기를 해야하기 때문에 불편함
  if (typeof num === "number") {
    num.toFixed();
  }
}

//

{
  // ###########################################################
  // 제네릭 함수로 만들어주면 함수의 인수에 따라서
  // 반환값을 가변적으로 정해줄 수 있다.
  // T : 타입 변수(타입을 담는 변수)
  // => 자바스크립트처럼 상황에 따라 다른 변수를 담을 수 있음
  // 즉, 타입 변수에 어떤 타입이 담기는 것이 언제 결정되는 거냐면..
  // 함수를 호출할때 마다 타입이 결정된다.
  // 아래 코드 func(10);  10 을 넘길때
  // ###########################################################

  function func<T>(value: T): T {
    return value;
  }

  // 마우스커서를 num 에 올려보면 number 타입으로 잘 추론되고 있다.
  // 즉, 인수에 따라서 잘 추론됨
  let num = func(10);

  let str = func("hello");

  // ###########################################################
  // 명시적인 호출 방법
  // 타입 변수에 할당되는 타입을 인수를 통해서 추론되도록 하지 말고
  // 프로그래머가 명시적으로 추론하도록 할 수도 있다.

  // 만약 number[] 가 아닌 튜플타입으로 하고 싶다면 타입 단언을 사용할 수도 있지만..
  // 아래 방식보다는 <> 로 명시적으로 호출할 수 있다.
  let arr = func([1, 2, 3]) as [number, number, number];

  // functin func<T> <T> 에 담기게 되어 (value: T), 그리고 반환값 :T 에 전달되게 된다.
  let arr2 = func<[number, number, number]>([1, 2, 3]);
}
